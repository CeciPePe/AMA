---
title: "Density estimation. GMM. DBSCAN"
author: "AMA-G5 : Gerard Gómez, Rudio Fida Cyrille, Cecilia Pérez"
output: html_document
date: "2023-10-04"
---

## Read libraries we need

```{r}
library(mclust)
library(sm)
library(fpc)

```

## Load the data: 

```{r}
load("BikeDay.Rdata")
X <- as.matrix(day[day$yr==1,c(10,14)])
```


## Exercice 1:

```{r}
GMM_BIC <- Mclust(X,G=2:6,modelNames = "VVV")
par(mfrow= c(2,2))
plot(GMM_BIC, what = "BIC")
title("BIC")
plot(GMM_BIC, what = "classification")
title("Classification")
plot(GMM_BIC, what = "uncertainty")
title("Uncertanty")
plot(GMM_BIC, what = "density")
title("Density")
```
  
On these plots, the results for the Gaussian Mixture Models can be seen, the highest BIC, when varying volume, shape, and orientation, is for 3 clusters. Looking at the classification plot we can observe that the blue and red clusters are very close to each other.

## Exercise 2: 

```{r}
a <- 0.25
sm.density(x = X, h = a*c(sd(X[,1]),sd(X[,2])),col=GMM_BIC$classification, display = 'slice')

```
  
By comparing this plot with the previous density plot, it can be seen that the top part of the plot, the green cluster from before, is not seen when the non-parametric density estimation is used. It seems that this density estimation is less precise than the previous one as it doesn't take in account the part with less concentrated points. Looking further, using this second-density estimation, it should probably estimates 2 clusters, compared to the three estimated by the parametric one.   

## Exercise 3

```{r}
k <- 3
a <- 0.4
clust.ind <- GMM_BIC$classification
plot(X,col=clust.ind)
for (j in 1:k){
  cl.j <- (clust.ind==j)
  sm.density(X[cl.j,],h=a*c(sd(X[cl.j,1]),sd(X[cl.j,2])), 
             display="slice",props=c(75),
             col=j, cex=4, add=TRUE)
}

```

When estimating the density for each cluster of points, we get results that make sense as the density is around the different concentration of points given by the clusterings.
By doing that, we obtain a result near to the parametric one but with 3 region as the parametric one had 2. 

## Exercise 4

```{r}
mnx <- mergenormals(X,GMM_BIC,method="bhat")
summary(mnx)
```
```{r}
k<-2
plot(X,col=mnx$clustering,main="Clusters obtained by merging Gaussian mixtures components")
```

Looking at the results from the mergenormals function, the red and the blue clusters that were close in the first exercise were merged into one cluster, so were left with $k=2$ clusters. The plot above shows the points corresponding to cluster 1 (black) and cluster 2 (red). 

## Exercise 5

```{r}

k=2
a=0.4
plot(X,col=mnx$clustering)
clust.ind <- mnx$clustering

for (j in 1:k){
  cl.j <- (clust.ind==j)
  h=a*c(sd(X[cl.j,1]),sd(X[cl.j,2]))
  sm.density(X[cl.j,],h=h, 
             display="slice",props=c(75),
             col=j, cex=4, add=TRUE)
}
```

The estimated density of the firsts cluster has evolved as we fused them. Now the estimated density is kind of the fusion between the two previous one. The estimation that we got now is very similar to the estimated density from the GMM from exercise 1.

## Exercise 6

```{r}
epsilon=c(0.25,0.5)
minPts=c(10,15,20)

Xs <- scale(X)

par(mfrow=c(2,3))
for(eps in epsilon)
{
  for (mP in minPts)
  {
    dbscan.ds <- dbscan::dbscan(Xs,eps = eps, minPts = mP)
plot(X, col=dbscan.ds$cluster+1, pch=dbscan.ds$cluster+1, 
     main=paste("eps=",eps,",minPts=",mP),
     xlab="temp",ylab="casual")
  }
}

db = dbscan::dbscan(Xs,eps = 0.5, minPts = 20)
table(db$cluster+1,mnx$clustering)
```

It is considered that the best representation is given by the dbscan when the epsilon is set at 0.5 and the minpoints are set at 20 as with these parameters the clustering method give a clear separation between the 2 different clusters. Comparing it to the mergenormals results, both separates the observations into the same cluster with the exception of 1 observation as it can be seen in the table. 

## Exercise 7

### GMM's clusters

```{r}
d = day[day$yr==1,]
GMM.c1 = which(GMM_BIC$classification==1) 
GMM.c2 = which(GMM_BIC$classification==2)
GMM.c3 = which(GMM_BIC$classification==3)
print("Cluster 1")
summary(d[GMM.c1,])

print("Cluster 2")
summary(d[GMM.c2,])

print("Cluster 3")
summary(d[GMM.c3,])
```

Looking at the summary of the three different clusters generated by the GMM, it can be seen that the season for clusters 2 and 3 has a media at 3 (fall), and on the other hand, cluster 1 has a median of 1 (spring). Moving on, to the month, for cluster 1, the median is 3 (march), and clusters 2 and 3 have a median of month 7 and 6.5 respectively. Next, on the weekday, cluster 1 has a median of Tuesday, cluster 2 has a median of Wednesday and Cluster 3 has a median of Friday. Regarding clusters 1 and 2, a majority of working days can be seen. On the other hand, cluster 3 has a majority of not working days. Looking at the weathersit variable, for all clusters it's mostly 1 (Clear, Few clouds, Partly cloudy, Partly cloudy), it can also be noticed that in none of the clusters, there is weathersit 4. Next, there is the temp, one of the variables used for the clustering. The mean of clusters 2 and 3 are very close, this being 0.5688 and 0.5573 respectively. On the other hand, cluster 1 has a lower normalized temperature of 0.30321. Similar thing happens with the atemp, which is the normalized filling temperature. Moving on,there is the humidity, which is more or less the same for all clusters, similarlyfor the windspeed. Next, looking at the casual, which is the other variable used for the clustering, this is the count of rental bikes by user registered, it can be seen that are clusters are more or less equally separated, by around 400. Moving on to the registered, it can be noticed that clusters 2 and 3 have a close value of registered rental bikes, compared to cluster 1 has a much lower value. Lastly, cnt, for the total amount of rental bikes,  cluster 1 has a much lower number, 2183 compared to cluster 2 and 3, which is 3889 and 4080 respectively.

### DBSCAN and mergenormals clusters

```{r}
db.c1 = which(db$cluster==0) 
db.c2 = which(db$cluster==1)

print("Cluster 1")
summary(d[db.c1,])

print("Cluster 2")
summary(d[db.c2,])

```

Looking at the clusters generated by the dbscan and the mergenormals, the previous cluster 3 is kept, but clusters 1 and 2 are merged. Only one cluster changed, therefore, it is necessary to only explain the new one. 
To start of, it can be seen that this cluster has most of its observations in the summer. Most of the observations were observed in July.  Regarding the weathersit, the same as before happens, most of them being 1, with no 4. Looking at the temperature, an average temperature of around 0.47 is seen, and an atemp of 0.45496. Looking at the humidity, this new cluster has a humidity of 0.64 and a windspeed of 0.19. Lastly, the casual for this new cluster is 594, a registered of 2680, and a total average of 3275. Looking at the working day, most of the observations were on working days. Regarding weekdays it can be seen that most of them were on Tuesdays. 

If we look more precisely on the weekday of each point, it appears clear that these two clusters separates the weekend from the other days. The cluster with more casual rent corresponds to the Saturday and Sunday which seems logical and the other points to the days from Monday to Friday. This can be visualized on the next figures. Following that idea, it makes more sense to fuse the cluster 1 and 2 from the GMM clustering. 

```{r}
# Week days distribution
plot(X, col=day$weekday+1, pch=dbscan.ds$cluster+1, 
     main=paste("Weekday distribution with dbscan clusters"),
     xlab="temp",ylab="casual")
legend(x = "topleft", title="Weekdays",  
       legend=c("Sunday", "Monday",'Tuesday','Wednesday','Thursday','Friday','Saturday'),col=day$weekday+1, lty=1, cex=0.8 ) 

# working days distribution
X <- as.matrix(day[day$yr==1 & day$workingday==0,c(10,14)])
X2 <- as.matrix(day[day$yr==1 & day$workingday==1,c(10,14)])
plot(X,col='red',main = "Workingday distribution")
points(X2,col="blue")
legend(x = "topleft", title="Working day",  
       legend=c("free day","working day"),col=c('red','blue'), lty=1, cex=0.8 ) 
```



